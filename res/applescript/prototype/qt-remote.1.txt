(*######################################################### UTILITY ######################################################### *)on get_window_ref(window_id)	tell application "QuickTime Player"		return window id window_id	end tellend get_window_refon get_window_ref_test()	tell application "QuickTime Player"		return my get_window_ref(id of window 1)	end tellend get_window_ref_test--get_window_ref_test()(*######################################################### DOCUMENT STATE ######################################################### *)on document_state(window_ref)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set answer to {}		set answer to answer & {_duration:duration of quicktime_document as integer}		set answer to answer & {_audio_volume:(audio volume of quicktime_document) * 100 as integer}		set answer to answer & {_current_time:current time of quicktime_document as integer}		set answer to answer & {_presenting:presenting of quicktime_document}		set answer to answer & {_rate:rate of quicktime_document as integer}		set answer to answer & {_file:file of quicktime_document as string}		set answer to answer & {_name:name of quicktime_document as string}		return answer	end tellend document_stateon document_state_test()	tell application "QuickTime Player"		return my document_state(window 1)	end tellend document_state_test--document_state_test()(*######################################################### WINDOW/APPLICATION STATE ######################################################### *)on window_state_by_ref(window_ref)	tell application "QuickTime Player"		set answer to {}		set answer to answer & {_window_id:id of window_ref}		set answer to answer & {_name:name of window_ref}		set answer to answer & {_document:my document_state(window_ref)}	end tellend window_state_by_refon window_state_by_ref_test()	tell application "QuickTime Player"		return my window_state_by_ref(window 1)	end tellend window_state_by_ref_test--window_state_by_ref_test()on window_state_by_id(window_id)	set window_ref to get_window_ref(window_id)	return window_state_by_ref(window_ref)end window_state_by_idon window_state_by_id_test()	tell application "QuickTime Player"		return my window_state_by_id(id of window 1)	end tellend window_state_by_id_test--window_state_by_id_test()on quicktime_state()	tell application "QuickTime Player"		set answer to {}		repeat with window_ref in windows			copy my window_state_by_ref(window_ref) to end of answer			--set answer to answer & {my window_state_by_ref(window_ref)}		end repeat		return answer	end tellend quicktime_state--quicktime_state()(*######################################################### APPLICATION/WINDOW/FILE MANAGEMENT ######################################################### *)on activate_quicktime_player()	activate application "QuickTime Player"	return quicktime_state()end activate_quicktime_player--activate_quicktime_player()on close_window(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		-- QT will not close the window if it is presenting, so we hide it ... 		set visible of window_ref to false		-- switch off presenting ...		set presenting of document of window_ref to false		-- do the actual close ... 		close window_ref	end tellend close_windowon close_window_test()	tell application "QuickTime Player"		return my close_window(id of window 1)	end tellend close_window_test--close_window_test()on open_file(file_path, time_out)	try		tell application "QuickTime Player"			with timeout of time_out seconds				set document_ref to open file file_path				repeat with candidate_window_ref in windows					if document_ref is equal to document of candidate_window_ref then						return my window_state_by_ref(candidate_window_ref)					end if				end repeat			end timeout		end tell	on error		-- we assume we got a timeout error as a result of 		-- an error dialog being shown to the user ... 		-- we try to dismiss it		activate application "QuickTime Player"		tell application "System Events"			beep			tell application process "QuickTime Player"				keystroke return			end tell		end tell	end tryend open_file--open_file("hard-disk:Users:rlong.unencrypted:Movies:TEDTalks _ A different way to think about creative genius - Elizabeth Gilbert (2009).mp4", 5)--open_file("rlong:projects", 5)on bring_window_forward(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set index of window_ref to 1	end tell	return window_state_by_ref(window_ref)end bring_window_forwardon bring_window_forward_test()	tell application "QuickTime Player"		return my bring_window_forward(id of window 1)	end tellend bring_window_forward_test-- bring_window_forward_test()(*######################################################### MEDIA CONTROL ######################################################### *)on play_pause(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		if rate of quicktime_document is equal to 0.0 then			set rate of quicktime_document to 1.0		else			set rate of quicktime_document to 0.0		end if	end tell	return window_state_by_ref(window_ref)end play_pauseon play_pause_test()	tell application "QuickTime Player"		return my play_pause(id of window 1)	end tellend play_pause_test--play_pause_test()on play_window(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set rate of quicktime_document to 1.0	end tell	return window_state_by_ref(window_ref)end play_windowon play_window_test()	tell application "QuickTime Player"		return my play_window(id of window 1)	end tellend play_window_test--play_window_test()on pause_window(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set rate of quicktime_document to 0.0	end tell	return window_state_by_ref(window_ref)end pause_windowon pause_test()	tell application "QuickTime Player"		return my pause_window(id of window 1)	end tellend pause_test--pause_test()on toggle_presenting(window_id)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set presenting of quicktime_document to not presenting of quicktime_document	end tell	return window_state_by_ref(window_ref)end toggle_presentingon toggle_presenting_test()	tell application "QuickTime Player"		return my toggle_presenting(id of window 1)	end tellend toggle_presenting_test--toggle_presenting_test()on set_rate(window_id, rate_int)	set window_ref to get_window_ref(window_id)	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set rate of quicktime_document to rate_int as real	end tell	return window_state_by_ref(window_ref)end set_rateon set_rate_test()	tell application "QuickTime Player"		return my set_rate(id of window 1, 32)	end tellend set_rate_test--set_rate_test()on set_volume(window_id, volume_int)	set window_ref to get_window_ref(window_id)	set volume_real to volume_int as real	set volume_real to volume_real / 100.0	tell application "QuickTime Player"		set quicktime_document to document of window_ref		set audio volume of quicktime_document to volume_real	end tell	return window_state_by_ref(window_ref)end set_volumeon set_volume_test()	tell application "QuickTime Player"		return my set_volume(id of window 1, 50)	end tellend set_volume_test-- tell application "QuickTime Player" set_volume(id of window 1, 50) of me --set_volume_test()(*######################################################### Finder / File System######################################################### *)on list_roots()	set answer to {}		tell application "Finder"				-- first the disks ... 		set all_disks to disks		--repeat with disk_ref in disks -- ... does not work		repeat with disk_ref in all_disks			set _disk to {_name:name of disk_ref}			set _disk to _disk & {_path:disk_ref as alias as text}			set _disk to _disk & {_type:"disk"}			set _disk to _disk & {_ejectable:ejectable of disk_ref}			set _disk to _disk & {_startup:startup of disk_ref}			set _disk to _disk & {_local_volume:local volume of disk_ref}						copy _disk to the end of answer			--set answer to answer & {folder_info}		end repeat				-- next the home folder ...		set home_ref to home as alias		if folder (home_ref as text) exists then			set _home to {_name:name of home}			set _home to _home & {_path:home_ref as text as text}			set _home to _home & {_type:"home"}			set _home to _home & {_ejectable:false}			set _home to _home & {_startup:false}			set _home to _home & {_local_volume:true}			copy _home to the end of answer		end if	end tell	return answerend list_roots--list_roots()on list_path(folder_path)		set answer to {_folder_path:folder_path}	set _sub_folders to {}	set _files to {}		set quick_and_dirty to true		if quick_and_dirty then		tell application "Finder"			set _sub_folders to name of folders of folder folder_path			set _files to name of files of folder folder_path		end tell	else -- slower but more technically correct 		tell application "Finder"						set target_container to alias folder_path			set contained_folders to folders of target_container			--repeat with sub_folder_ref in folders of target_container -- ... does not work			repeat with sub_folder_ref in contained_folders				set sub_folder to {_name:name of sub_folder_ref}				set sub_folder to sub_folder & {_path:sub_folder_ref as alias as text}				copy sub_folder to the end of _sub_folders			end repeat						set contained_files to files of target_container			repeat with file_ref in contained_files				set _file to {_name:name of file_ref}				set _file to _file & {_path:file_ref as text}				copy _file to the end of _files			end repeat					end tell	end if	set answer to answer & {_folders:_sub_folders}	set answer to answer & {_files:_files}end list_path--list_path("hard-disk:")--list_path("rlong:")--list_path("hard-disk:Library:")--list_path("hard-disk:Applications:")on file_info(file_path)		tell application "Finder"		set file_info_ref to info for file file_path		set answer to {_file_path:file_path}		set answer to answer & {_alias:alias of file_info_ref}		set answer to answer & {_type_identifier:type identifier of file_info_ref as string}		if file_info_ref contains {locked:true} then			set answer to answer & {_locked:true}		else			set answer to answer & {_locked:false}		end if		if file_info_ref contains {busy status:true} then			set answer to answer & {_busy_status:true}		else			set answer to answer & {_busy_status:false}		end if		return answer	end tell	end file_info--file_info("hard-disk:Users:rlong.unencrypted:Movies:TEDTalks _ A different way to think about creative genius - Elizabeth Gilbert (2009).mp4")